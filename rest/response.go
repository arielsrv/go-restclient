package rest

import (
	"encoding/xml"
	"errors"
	"fmt"
	"maps"
	"mime"
	"net/http"
	"net/http/httputil"
	"strings"
	"sync/atomic"
	"time"
	"unsafe"
)

// Response represents an HTTP response from a REST API call.
// It wraps the standard http.Response and provides additional functionality
// for handling REST API responses, including caching, error handling, and
// content deserialization.
type Response struct {
	// Response is the underlying HTTP response.
	*http.Response

	// Err contains any error that occurred during the request.
	Err error

	// cached indicates whether this response was retrieved from cache.
	cached atomic.Value

	// Problem contains RFC7807 problem details if the response is an error.
	Problem *Problem

	// ttl is the time-to-live for caching this response.
	ttl *time.Time

	// lastModified is the Last-Modified timestamp from the response headers.
	lastModified *time.Time

	// etag is the ETag value from the response headers.
	etag string

	// bytes contains the response body as a byte slice.
	bytes []byte

	// revalidate indicates whether this response needs revalidation with the server.
	revalidate bool
}

// size returns the size of the Response in bytes.
// This is used for cache cost calculation.
func (r *Response) size() int64 {
	size := int64(unsafe.Sizeof(*r))

	size += int64(len(r.bytes))
	size += int64(len(r.etag))
	size += int64(unsafe.Sizeof(r.Problem))
	size += int64(unsafe.Sizeof(r.ttl))
	size += int64(unsafe.Sizeof(r.lastModified))

	if r.Response != nil {
		size += int64(len(r.Proto))
		size += int64(len(r.Status))
	}

	return size
}

// Problem represents an RFC7807 API problem response.
// It follows the standard defined in https://datatracker.ietf.org/doc/html/rfc7807
// and can be serialized to/from both JSON and XML formats.
type Problem struct {
	XMLName xml.Name `json:"-" xml:"problem,omitempty"`
	XMLNS   xml.Name `json:"-" xml:"xmlns,attr,omitempty"`

	// Type is a URI reference that identifies the problem type.
	Type string `json:"type,omitempty" xml:"type,omitempty"`

	// Title is a short, human-readable summary of the problem type.
	Title string `json:"title,omitempty" xml:"title,omitempty"`

	// Detail is a human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail,omitempty" xml:"detail,omitempty"`

	// Instance is a URI reference that identifies the specific occurrence of the problem.
	Instance string `json:"instance,omitempty" xml:"instance,omitempty"`

	// Status is the HTTP status code generated by the origin server.
	Status int `json:"status,omitempty" xml:"status,omitempty"`
}

// String returns the Response Body as a string.
// This is useful for accessing the raw response content.
func (r *Response) String() string {
	return string(r.bytes)
}

// Raw returns the Response Body as a string.
// This is an alias for String() for backward compatibility.
func (r *Response) Raw() string {
	return r.String()
}

// FillUp deserializes the response body into the provided value.
// The value should be a pointer to a struct or map[string]any.
// The content type of the response is used to determine the deserialization method.
// Returns an error if deserialization fails or if the content type is not supported.
func (r *Response) FillUp(fill any) error {
	contentType := strings.ToLower(r.Header.Get(CanonicalContentTypeHeader))
	if contentType == "" {
		contentType = http.DetectContentType(r.bytes)
	}

	mediaType, _, err := mime.ParseMediaType(contentType)
	if err != nil {
		return fmt.Errorf("invalid content type: %s", contentType)
	}

	for mediaContent := range maps.Values(readMarshalers) {
		values := mediaContent.DefaultHeaders().Values(CanonicalContentTypeHeader)
		for i := range values {
			value := values[i]
			if mediaType == value {
				return mediaContent.Unmarshal(r.bytes, fill)
			}
		}
	}

	return fmt.Errorf("unmarshal fail, unsupported content type: %s", contentType)
}

// Deserialize is a generic function that deserializes the response body into a value of type T.
// It returns the deserialized value and any error that occurred during deserialization.
// Returns an error if the response is nil or if deserialization fails.
func Deserialize[T any](response *Response) (T, error) {
	var dflt T
	if response == nil {
		return dflt, errors.New("response is nil")
	}

	var result T
	err := response.FillUp(&result)
	if err != nil {
		return dflt, err
	}

	return result, nil
}

// Cached returns true if the response was retrieved from the cache.
// This can be used to determine if the response came from the server or the cache.
func (r *Response) Cached() bool {
	if hit, ok := r.cached.Load().(bool); ok {
		return hit
	}

	return false
}

// Debug returns a string representation of the request and response for debugging.
// It includes the full request (including headers and body) and the response headers,
// followed by the response body.
// This is useful for troubleshooting API interactions.
func (r *Response) Debug() string {
	var strReq, strResp string

	if req, err := httputil.DumpRequest(r.Request, true); err != nil {
		strReq = err.Error()
	} else {
		strReq = string(req)
	}

	if resp, err := httputil.DumpResponse(r.Response, false); err != nil {
		strResp = err.Error()
	} else {
		strResp = string(resp)
	}

	const separator = "--------\n"

	dump := separator
	dump += "REQUEST\n"
	dump += separator
	dump += strReq
	dump += "\n" + separator
	dump += "RESPONSE\n"
	dump += separator
	dump += strResp
	dump += r.String() + "\n"

	return dump
}

// IsOk checks if the response status code is within the 200-399 range.
// Returns true if the status code indicates success, false otherwise.
func (r *Response) IsOk() bool {
	return r.StatusCode >= http.StatusOK && r.StatusCode < http.StatusBadRequest
}

// VerifyIsOkOrError checks if the response is OK or if an error occurred.
// Returns nil if the response is OK, otherwise returns an error with details.
// If r.Err is not nil, it returns that error.
// If the status code is not in the success range, it returns an error with the status code and response body.
func (r *Response) VerifyIsOkOrError() error {
	if r.Err != nil {
		return r.Err
	}

	if !r.IsOk() {
		return fmt.Errorf("status code %d, body: %s", r.StatusCode, r.String())
	}

	return nil
}

// Hit marks the response as a hit in the cache.
// This is used internally by the caching system.
func (r *Response) Hit() {
	r.cached.Store(true)
}
